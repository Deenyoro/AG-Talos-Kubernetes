---
# Job Queue Health Monitor - Exposes detailed metrics about Zammad's job processing
apiVersion: apps/v1
kind: Deployment
metadata:
  name: zammad-job-queue-monitor
  namespace: default
  labels:
    app.kubernetes.io/name: zammad
    app.kubernetes.io/component: job-queue-monitor
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: zammad
      app.kubernetes.io/component: job-queue-monitor
  template:
    metadata:
      labels:
        app.kubernetes.io/name: zammad
        app.kubernetes.io/component: job-queue-monitor
    spec:
      containers:
        - name: job-queue-monitor
          image: python:3.13-alpine
          command:
            - python3
            - -c
            - |
              import http.server
              import socketserver
              import subprocess
              import json
              import time
              import threading
              from datetime import datetime, timedelta
              
              # Global metrics storage
              metrics = {
                  'pending_jobs': 0,
                  'locked_jobs': 0,
                  'failed_jobs': 0,
                  'old_pending_jobs': 0,
                  'job_processing_rate': 0,
                  'last_job_processed': 0,
                  'scheduler_responsive': 1,
                  'notification_jobs_pending': 0,
                  'webhook_jobs_pending': 0,
                  'email_jobs_pending': 0,
                  'last_update': time.time()
              }
              
              def get_job_metrics():
                  """Query Zammad database for job queue metrics"""
                  try:
                      # Query job queue status
                      cmd = [
                          'kubectl', 'exec', '-n', 'default', 
                          'deployment/zammad-railsserver', '--',
                          'bundle', 'exec', 'rails', 'runner',
                          '''
                          require "json"
                          now = Time.now
                          
                          # Basic job counts
                          all_jobs = Delayed::Job.count
                          pending = Delayed::Job.where(failed_at: nil, locked_at: nil).where("run_at <= ?", now).count
                          locked = Delayed::Job.where.not(locked_at: nil).count
                          failed = Delayed::Job.where.not(failed_at: nil).count
                          
                          # Old pending jobs (stuck for >10 minutes)
                          old_pending = Delayed::Job.where(failed_at: nil, locked_at: nil)
                                                   .where("run_at <= ?", now - 600).count
                          
                          # Notification-specific job counts
                          notification_jobs = Delayed::Job.where(failed_at: nil)
                                                          .where("handler LIKE ? OR handler LIKE ?", 
                                                                 "%NotificationFactory%", "%webhook%").count
                          
                          email_jobs = Delayed::Job.where(failed_at: nil)
                                                   .where("handler LIKE ?", "%Mail%").count
                          
                          # Recent job processing activity
                          recent_completed = Delayed::Job.where("updated_at > ?", now - 300).count
                          
                          # Last successful job timestamp
                          last_job = Delayed::Job.where.not(failed_at: nil)
                                                 .order(updated_at: :desc).first
                          last_job_time = last_job ? last_job.updated_at.to_i : 0
                          
                          result = {
                            pending_jobs: pending,
                            locked_jobs: locked,
                            failed_jobs: failed,
                            old_pending_jobs: old_pending,
                            notification_jobs_pending: notification_jobs,
                            email_jobs_pending: email_jobs,
                            recent_completed: recent_completed,
                            last_job_processed: last_job_time,
                            total_jobs: all_jobs,
                            timestamp: now.to_i
                          }
                          
                          puts result.to_json
                          '''
                      ]
                      
                      result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                      if result.returncode == 0:
                          # Parse the JSON output from the Rails command
                          lines = result.stdout.strip().split('\n')
                          json_line = None
                          for line in lines:
                              if line.startswith('{'):
                                  json_line = line
                                  break
                          
                          if json_line:
                              data = json.loads(json_line)
                              
                              # Calculate job processing rate (jobs/minute)
                              processing_rate = data.get('recent_completed', 0) / 5.0  # 5-minute window
                              
                              # Update global metrics
                              metrics.update({
                                  'pending_jobs': data.get('pending_jobs', 0),
                                  'locked_jobs': data.get('locked_jobs', 0),
                                  'failed_jobs': data.get('failed_jobs', 0),
                                  'old_pending_jobs': data.get('old_pending_jobs', 0),
                                  'job_processing_rate': processing_rate,
                                  'last_job_processed': data.get('last_job_processed', 0),
                                  'notification_jobs_pending': data.get('notification_jobs_pending', 0),
                                  'email_jobs_pending': data.get('email_jobs_pending', 0),
                                  'scheduler_responsive': 1,
                                  'last_update': time.time()
                              })
                              
                              print(f"Updated metrics: pending={metrics['pending_jobs']}, rate={processing_rate:.2f}/min")
                          else:
                              print("No JSON output found in Rails command result")
                              metrics['scheduler_responsive'] = 0
                      else:
                          print(f"Rails command failed: {result.stderr}")
                          metrics['scheduler_responsive'] = 0
                          
                  except Exception as e:
                      print(f"Error getting job metrics: {e}")
                      metrics['scheduler_responsive'] = 0
              
              def metrics_updater():
                  """Background thread to update metrics every 30 seconds"""
                  while True:
                      get_job_metrics()
                      time.sleep(30)
              
              class MetricsHandler(http.server.BaseHTTPRequestHandler):
                  def do_GET(self):
                      if self.path == '/metrics':
                          self.send_response(200)
                          self.send_header('Content-type', 'text/plain; version=0.0.4; charset=utf-8')
                          self.end_headers()
                          
                          # Generate Prometheus metrics
                          prometheus_metrics = f'''# HELP zammad_job_queue_pending_jobs Number of pending jobs in the queue
              # TYPE zammad_job_queue_pending_jobs gauge
              zammad_job_queue_pending_jobs {metrics['pending_jobs']}
              
              # HELP zammad_job_queue_locked_jobs Number of locked jobs currently being processed
              # TYPE zammad_job_queue_locked_jobs gauge
              zammad_job_queue_locked_jobs {metrics['locked_jobs']}
              
              # HELP zammad_job_queue_failed_jobs Number of failed jobs
              # TYPE zammad_job_queue_failed_jobs gauge
              zammad_job_queue_failed_jobs {metrics['failed_jobs']}
              
              # HELP zammad_job_queue_old_pending_jobs Number of jobs pending for more than 10 minutes
              # TYPE zammad_job_queue_old_pending_jobs gauge
              zammad_job_queue_old_pending_jobs {metrics['old_pending_jobs']}
              
              # HELP zammad_job_processing_rate Jobs processed per minute
              # TYPE zammad_job_processing_rate gauge
              zammad_job_processing_rate {metrics['job_processing_rate']}
              
              # HELP zammad_scheduler_responsive Whether the scheduler is responding to queries
              # TYPE zammad_scheduler_responsive gauge
              zammad_scheduler_responsive {metrics['scheduler_responsive']}
              
              # HELP zammad_notification_jobs_pending Number of pending notification jobs
              # TYPE zammad_notification_jobs_pending gauge
              zammad_notification_jobs_pending {metrics['notification_jobs_pending']}
              
              # HELP zammad_email_jobs_pending Number of pending email jobs
              # TYPE zammad_email_jobs_pending gauge
              zammad_email_jobs_pending {metrics['email_jobs_pending']}
              
              # HELP zammad_last_job_processed_timestamp Timestamp of last processed job
              # TYPE zammad_last_job_processed_timestamp gauge
              zammad_last_job_processed_timestamp {metrics['last_job_processed']}
              
              # HELP zammad_metrics_last_update_timestamp Timestamp of last metrics update
              # TYPE zammad_metrics_last_update_timestamp gauge
              zammad_metrics_last_update_timestamp {metrics['last_update']}
              '''
                          self.wfile.write(prometheus_metrics.encode())
                      elif self.path == '/health':
                          self.send_response(200)
                          self.send_header('Content-type', 'application/json')
                          self.end_headers()
                          health_data = {
                              'status': 'healthy' if metrics['scheduler_responsive'] else 'unhealthy',
                              'metrics': metrics
                          }
                          self.wfile.write(json.dumps(health_data).encode())
                      else:
                          self.send_response(404)
                          self.end_headers()
                  
                  def log_message(self, format, *args):
                      # Reduce log noise
                      pass
              
              # Start metrics updater thread
              metrics_thread = threading.Thread(target=metrics_updater, daemon=True)
              metrics_thread.start()
              
              # Initial metrics collection
              get_job_metrics()
              
              print("Starting Zammad job queue monitor on port 9090")
              with socketserver.TCPServer(("", 9090), MetricsHandler) as httpd:
                  httpd.serve_forever()
          ports:
            - containerPort: 9090
              name: metrics
          resources:
            requests:
              cpu: 10m
              memory: 32Mi
            limits:
              cpu: 50m
              memory: 64Mi
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            runAsNonRoot: true
            runAsUser: 1000
      securityContext:
        fsGroup: 1000
---
apiVersion: v1
kind: Service
metadata:
  name: zammad-job-queue-monitor
  namespace: default
  labels:
    app.kubernetes.io/name: zammad
    app.kubernetes.io/component: job-queue-monitor
spec:
  selector:
    app.kubernetes.io/name: zammad
    app.kubernetes.io/component: job-queue-monitor
  ports:
    - name: metrics
      port: 9090
      targetPort: 9090
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: zammad-job-queue-monitor
  namespace: default
  labels:
    app.kubernetes.io/name: zammad
    app.kubernetes.io/component: job-queue-monitor
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: zammad
      app.kubernetes.io/component: job-queue-monitor
  endpoints:
    - port: metrics
      interval: 30s
      path: /metrics
